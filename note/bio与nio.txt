1.bio 同步阻塞。
2.nio  同步不阻塞。//阻塞就是cpu等待一个任务完成之后，才接着执行别的事

3. inputStream --fileInputStream read.
   outPutStream -- fileOutPutStream write.

发起请求，必须得到响应就是阻塞


socket(插座)也就是套接字，计算机之间的一种通信方式或者约定。
scoket--通过ip地址+端口号来确定。
  两个程序之间通过scoket来连接
accept()接收客户端的消息，之后进入阻塞，知道在接受到来自客户端的消息。listen(监听)处于睡眠状态，直到客户端发送请求才被唤醒。
  tcp协议必须创建连接
面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。
//接收方可以完整接收数据。
而udp不需要建立连接：数据包里面有地址信息， udp如果因为网络中断发送失败，不会给应用层发送错误信息 。

Scoket(客户端)  serverScoket(服务端)

套接字的种类：internet(比较常用),unix
    套接字的传输方式：流格式套接字：是一种双向，可靠的通信方法，可以保证数据准确的传送到另一台计算机。
    SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。

面向连接与无连接的区别：
1.无连接是基于udp协议：发送端只管发送，接收端只负责接受，不会去问发送端是否发送完毕，数据是否完整。//传输效率高
2.面向连接：基于tcp(传输控制协议)，建立连接（3次握手，4次挥手），发送端发送数据之后，必须要受到接收端的响应，否则就会重新建立连接，重新发送

osi7层模型：应用层（程序需要的数据）--表示层---会话层---传输层---网络层（ip协议）--数据链路层--物理层（网络接口）
tcp/ip概念层：应用层--传输层--网络层--网络接口

//只能同层之间进行通信，数据只能逐层传递，不能跨越。
                                                                //cmd下ipconfig/all 查看
//ip 网络地址。一个局域网才有一个ip地址。 通过网卡的mac地址。每台计算机的mac地址(本机的物理地址)都不一样，要发送信息到哪个程序，通过程序的端口。

tcp粘包问题(数据无边界性)：发送端发送三次数据，接收端一次接受。发送 1,3 接受13.
udp不会粘包（udp里面会包含消息头，里面就包含了消息来源）tcp会将间隔时间小，数据量小的进行合并，封装发送给接受端，udp就不会进行合并
怎么解决：将每一条数据的长度也放进去，应用层根据数据的长度来读取数据。

tcp的建立连接过程：客户端发送数据包（里面有syn,ack,seq）ack是确认的标志(通过seq+1来填充)。三次握手就是为了确认是否收到数据包。
客户端与服务器都进入了ESTABLISED状态表示建立连接成功。ack确认包很很重要是保证数据传输成功的标志。
                                                      如果传输数据 ack=seq+数据字节数+1

tcp四次挥手：关闭连接。进入closed状态表示关闭成功
A;发送关闭的请求 fin,
B:收到，并发送要准备一下 的数据包。
B：可以关闭连接的数据包，
A：我收到了， 发送seq,在接受ack是否未seq+1.

inetAddress in = inetAddress .getLocalhost();//获取本地ip地址，主机名
